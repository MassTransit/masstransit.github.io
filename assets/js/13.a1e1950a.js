(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{446:function(e,t,i){"use strict";i.r(t);var s=i(25),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h1",{attrs:{id:"conductor"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#conductor"}},[e._v("#")]),e._v(" Conductor")]),e._v(" "),i("p",[i("em",[e._v("Conductor")]),e._v(" is a messaging service mesh that extends MassTransit to include run-time service discovery, advanced message routing, and monitoring. Composed of a consistent set of capabilities, "),i("em",[e._v("Conductor")]),e._v(" decouples services and reduces infrastructure configuration, and keeps routing, fault handling, and monitoring separated. "),i("em",[e._v("Conductor")]),e._v(" can be configured using existing consumers, sagas, and activities, without modification, reducing adoption time and effort.")]),e._v(" "),i("blockquote",[i("p",[i("em",[e._v("Conductor")]),e._v(" is a long journey, in fact, the code has been under thought and design for the past two years. Features will continue to be added, based upon demand and adoption, and it is early in the journey.")])]),e._v(" "),i("h2",{attrs:{id:"architecture"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#architecture"}},[e._v("#")]),e._v(" Architecture")]),e._v(" "),i("p",[e._v("Conductor's core architectural principle is "),i("em",[e._v("extensibility")]),e._v(". As a modern architecture built upon the learning from decades of prior art, which includes everything from SOA, the ESB, and even the Atari 2600 game console, Conductor provides a set of atoms which can be composed into a variety of capabilities. These atoms provide the basic building blocks for creating distributed services.")]),e._v(" "),i("p",[e._v("Services that depend on other services are inheritently coupled to those services. Despite the marketecture about microservices being loosely-coupled, they are still coupled to their dependencies. And unlike a monolithic application which is coupled at design-time, development-time, and compile-time, microservices are coupled at run-time, which makes ensuring that all dependencies are available even more complicated than during earlier stages of development.")]),e._v(" "),i("p",[e._v("Conductor consists of several components, each of which has a specific function.")]),e._v(" "),i("h3",{attrs:{id:"service-endpoint"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#service-endpoint"}},[e._v("#")]),e._v(" Service Endpoint")]),e._v(" "),i("p",[e._v("MassTransit has three endpoint types.")]),e._v(" "),i("ul",[i("li",[i("em",[e._v("Receive endpoints")]),e._v(" connect message consumers to the broker via a queue or subscription.")]),e._v(" "),i("li",[i("em",[e._v("Send endpoints")]),e._v(" send messages to a specific destination such as a queue or an exchange on the broker.")]),e._v(" "),i("li",[i("em",[e._v("Publish endpoints")]),e._v(" publish messages to connected receive endpoints, creating a copy of the message in each receive endpoints input queue.")])]),e._v(" "),i("p",[e._v("Conductor adds a new endpoint type, the "),i("em",[e._v("Service Endpoint")]),e._v(". A service endpoint is a managed receive endpoint. As consumers, sagas, and activities are configured, the service endpoint captures the details: message types, consumer definitions, sent message and published events, states, activities, arguments and logs. These details are stored and advertised by the service endpoint so that they can be discovered at run-time.")]),e._v(" "),i("p",[e._v("A service endpoint uses a separate queue for control messages. By default, the "),i("em",[e._v("Control")]),e._v(" suffix is appended to the queue name in the matching name format. So, using the kebab-case endpoint name formatter, the control queue for "),i("code",[e._v("submit-order")]),e._v(" would be "),i("code",[e._v("submit-order-control")]),e._v(". The alternative, which is highly recommended, is to use an instance-specific endpoint for control traffic that is unique to each "),i("em",[e._v("service instance")]),e._v(".")]),e._v(" "),i("h3",{attrs:{id:"service-instance"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#service-instance"}},[e._v("#")]),e._v(" Service Instance")]),e._v(" "),i("p",[e._v("A "),i("em",[e._v("service instance")]),e._v(" is a logical construct containing one or more service endpoints on the same bus instance. Each service instance has a temporary unique identifier ("),i("em",[e._v("Guid InstanceId")]),e._v(") that is generated every time the bus is started. When multiple instances of the same bus are started (scale out), each instance has its own unique identifier.")]),e._v(" "),i("p",[e._v("Each "),i("em",[e._v("service instance")]),e._v(" can have its own control queue, which is the preferred approach. Endpoint-specific control queues are shared by all service instances, so control messages are only consumed by one of the service instances. Instance-specific control queues allow each instance to receive all control traffic from the "),i("em",[e._v("service client")]),e._v(". Instance-specific control queues are named "),i("code",[e._v("Instance-<id>")]),e._v(", which in kebab-case would be "),i("code",[e._v("instance-abc123xyz")]),e._v(", and are temporary auto-delete queues.")]),e._v(" "),i("h3",{attrs:{id:"service-client"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#service-client"}},[e._v("#")]),e._v(" Service Client")]),e._v(" "),i("p",[e._v("The "),i("em",[e._v("service client")]),e._v(" is the client-side of "),i("em",[e._v("Conductor")]),e._v(", and extends the "),i("code",[e._v("IClientFactory")]),e._v(" and "),i("code",[e._v("IRequestClient")]),e._v(" interfaces. The service client "),i("em",[e._v("links")]),e._v(" to service endpoints at run-time to discover service details, including the address, message type, and other related information. The service client also keeps track of service endpoint capabilities, such as client-side partitioning and instance-specific endpoints.")]),e._v(" "),i("p",[e._v("When an application creates a request client, the request type is used to discover the service endpoint. A "),i("em",[e._v("Link")]),e._v(" event is published, and the response contains the service address for that message type along with the details for every known service instance (up or down). Service and instance details are retained until they expire or until the bus is stopped.")]),e._v(" "),i("div",{staticClass:"custom-block tip"},[i("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),i("p",[e._v("A least one instance of a service endpoint must be started for the service client to discover the service address. Which in practice makes sense – an application will not receive a request response from a service endpoint that is offline.")])])])}),[],!1,null,null,null);t.default=n.exports}}]);